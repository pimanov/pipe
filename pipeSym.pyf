!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module pipeSym ! in 
    interface  ! in :pipeSym
        subroutine down(fncp,u,v,w,t,dt,Dp,Imax,Jmax)
            character*24, intent(in) :: fncp
            real*8, intent(inout), dimension(Imax+1, Jmax+1, *) :: u
            real*8, intent(inout), dimension(Imax+1, Jmax+1, *), depend(Imax,Jmax) :: v
            real*8, intent(inout), dimension(Imax+1, Jmax+1, *), depend(Imax,Jmax) :: w
            real*8, intent(in) :: t
            real*8, intent(in) :: dt
            real*8, intent(in) :: Dp
            integer, intent(hide), depend(u) :: Imax=(shape(u,0)-1)
            integer, intent(hide), depend(u) :: Jmax=(shape(u,1)-1)
            real*8 :: Xmax
            real*8 :: epsr
            integer :: nsym
            real*8 :: hx
            integer :: Im
            integer :: lx
            real*8 dimension(129) :: rt
            real*8 dimension(129) :: rt1
            real*8 dimension(129) :: yt
            real*8 dimension(129) :: yt1
            real*8 :: hr
            integer :: Jm
            real*8 :: ht
            integer :: Km
            integer :: lt
            real*8 :: Re
            common /dim/ Xmax,epsr,nsym
            common /dimx/ hx,Im,lx
            common /dimr/ rt,rt1,yt,yt1,hr,Jm
            common /dimt/ ht,Km,lt
            common /Re/ Re
        end subroutine down
        subroutine load(fncp,u,v,w,t,dt,Dp,Imax,Jmax,Kmax)
            character*24, intent(in) :: fncp
            real*8, intent(inout), dimension(Imax+1, Jmax+1, Kmax+1) :: u
            real*8, intent(inout), dimension(Imax+1, Jmax+1, Kmax+1), depend(Imax,Jmax,Kmax) :: v
            real*8, intent(inout), dimension(Imax+1, Jmax+1, Kmax+1), depend(Imax,Jmax,Kmax) :: w
            real*8, intent(out) :: t
            real*8, intent(out) :: dt
            real*8, intent(out) :: Dp
            integer, intent(hide), depend(u) :: Imax=(shape(u,0)-1)
            integer, intent(hide), depend(u) :: Jmax=(shape(u,1)-1)
            integer, intent(hide), depend(u) :: Kmax=(shape(u,2)-1)
            real*8 :: Xmax
            real*8 :: epsr
            integer :: nsym
            real*8 :: hx
            integer :: Im
            integer :: lx
            real*8 dimension(129) :: rt
            real*8 dimension(129) :: rt1
            real*8 dimension(129) :: yt
            real*8 dimension(129) :: yt1
            real*8 :: hr
            integer :: Jm
            real*8 :: ht
            integer :: Km
            integer :: lt
            real*8 :: Re
            common /dim/ Xmax,epsr,nsym
            common /dimx/ hx,Im,lx
            common /dimr/ rt,rt1,yt,yt1,hr,Jm
            common /dimt/ ht,Km,lt
            common /Re/ Re
        end subroutine load
        subroutine init_like(fncp)
            character*24, intent(in) :: fncp
            real*8 :: Xmax
            real*8 :: epsr
            integer :: nsym
            real*8 :: hx
            integer :: Im
            integer :: lx
            real*8 dimension(129) :: rt
            real*8 dimension(129) :: rt1
            real*8 dimension(129) :: yt
            real*8 dimension(129) :: yt1
            real*8 :: hr
            integer :: Jm
            real*8 :: ht
            integer :: Km
            integer :: lt
            real*8 :: Re
            common /dim/ Xmax,epsr,nsym
            common /dimx/ hx,Im,lx
            common /dimr/ rt,rt1,yt,yt1,hr,Jm
            common /dimt/ ht,Km,lt
            common /Re/ Re
        end subroutine init_like
        subroutine mean(u,a,Imax,Jmax)
            real*8, intent(inout), dimension(Imax+1, Jmax+1, *) :: u
            real*8, intent(out,hide) :: a
            integer, intent(hide), depend(u) :: Imax=(shape(u,0)-1)
            integer, intent(hide), depend(u) :: Jmax=(shape(u,1)-1)
        end subroutine mean
        subroutine divmax(u,v,w,dd,Imax,Jmax)
            real*8, intent(inout), dimension(Imax+1, Jmax+1, *) :: u
            real*8, intent(inout), dimension(Imax+1, Jmax+1, *), depend(Imax,Jmax) :: v
            real*8, intent(inout), dimension(Imax+1, Jmax+1, *), depend(Imax,Jmax) :: w
            real*8, intent(out,hide) :: dd
            integer, intent(hide), depend(u) :: Imax=(shape(u,0)-1)
            integer, intent(hide), depend(u) :: Jmax=(shape(u,1)-1)
        end subroutine divmax
        subroutine com ! in :pipeSym:com.for
            real*8 :: Xmax
            real*8 :: epsr
            integer :: nsym
            real*8 :: hx
            integer :: Im
            integer :: lx
            real*8 dimension(129) :: rt
            real*8 dimension(129) :: rt1
            real*8 dimension(129) :: yt
            real*8 dimension(129) :: yt1
            real*8 :: hr
            integer :: Jm
            real*8 :: ht
            integer :: Km
            integer :: lt
            real*8 :: Re
            common /dim/ Xmax,epsr,nsym
            common /dimx/ hx,Im,lx
            common /dimr/ rt,rt1,yt,yt1,hr,Jm
            common /dimt/ ht,Km,lt
            common /Re/ Re
        end subroutine com
        subroutine pres(u,v,w,p,ub,Imax,Jmax) ! in :pipeSym:pres.for
            real*8, intent(inout), dimension(Imax+1, Jmax+1, *) :: u
            real*8, intent(inout), dimension(Imax+1, Jmax+1, *), depend(Imax,Jmax) :: v
            real*8, intent(inout), dimension(Imax+1, Jmax+1, *), depend(Imax,Jmax) :: w
            real*8, intent(inout), dimension(Imax+1, Jmax+1, *), depend(Imax,Jmax) :: p
            real*8, intent(in) :: ub
            integer, intent(hide), depend(u) :: Imax=(shape(u,0)-1)
            integer, intent(hide), depend(u) :: Jmax=(shape(u,1)-1)
            real*8 :: hx
            integer :: Im
            integer :: lx
            real*8 dimension(129) :: rt
            real*8 dimension(129) :: rt1
            real*8 dimension(129) :: yt
            real*8 dimension(129) :: yt1
            real*8 :: hr
            integer :: Jm
            real*8 :: ht
            integer :: Km
            integer :: lt
            common /dimx/ hx,Im,lx
            common /dimr/ rt,rt1,yt,yt1,hr,Jm
            common /dimt/ ht,Km,lt
        end subroutine pres
        subroutine rp(t,u,v,w,ut,vt,wt,ox,or,ot,Imax,Jmax) ! in :pipeSym:rp.for
            real*8, intent(in) :: t
            real*8, intent(inout), dimension(Imax+1,Jmax+1,*) :: u
            real*8, intent(inout), dimension(Imax+1,Jmax+1,*), depend(Imax,Jmax) :: v
            real*8, intent(inout), dimension(Imax+1,Jmax+1,*), depend(Imax,Jmax) :: w
            real*8, intent(inout), dimension(Imax+1,Jmax+1,*), depend(Imax,Jmax) :: ut
            real*8, intent(inout), dimension(Imax+1,Jmax+1,*), depend(Imax,Jmax) :: vt
            real*8, intent(inout), dimension(Imax+1,Jmax+1,*), depend(Imax,Jmax) :: wt
            real*8, intent(inout), dimension(Imax+1,Jmax+1,*), depend(Imax,Jmax) :: ox
            real*8, intent(inout), dimension(Imax+1,Jmax+1,*), depend(Imax,Jmax) :: or
            real*8, intent(inout), dimension(Imax+1,Jmax+1,*), depend(Imax,Jmax) :: ot
            integer, intent(hide), depend(u) :: Imax = (shape(u,0)-1)
            integer, intent(hide), depend(u) :: Jmax = (shape(u,1)-1)
            real*8 dimension(129) :: rt
            real*8 dimension(129) :: rt1
            real*8 dimension(129) :: yt
            real*8 dimension(129) :: yt1
            real*8 :: hr
            integer :: Jm
            real*8 :: Re
            real*8 :: hx
            integer :: Im
            integer :: lx
            real*8 :: ht
            integer :: Km
            integer :: lt
            common /dimr/ rt,rt1,yt,yt1,hr,Jm
            common /Re/ Re
            common /dimx/ hx,Im,lx
            common /dimt/ ht,Km,lt
        end subroutine rp
        subroutine step(t,dt,tol,u,v,w,ut,vt,wt,u2,v2,w2,u3,v3,w3,ox,or,ot,p,cf,Imax,Jmax) ! in :pipeSym:step.for
            real*8, intent(in,out) :: t
            real*8, intent(in,out) :: dt
            real*8, intent(in) :: tol
            real*8, intent(inout), dimension(Imax+1,Jmax+1,*)  :: u
            real*8, intent(inout), dimension(Imax+1,Jmax+1,*), depend(Imax,Jmax) :: v
            real*8, intent(inout), dimension(Imax+1,Jmax+1,*), depend(Imax,Jmax) :: w
            real*8, intent(inout), dimension(Imax+1,Jmax+1,*), depend(Imax,Jmax) :: ut
            real*8, intent(inout), dimension(Imax+1,Jmax+1,*), depend(Imax,Jmax) :: vt
            real*8, intent(inout), dimension(Imax+1,Jmax+1,*), depend(Imax,Jmax) :: wt
            real*8, intent(cache,hide), dimension(Imax+1,Jmax+1,shape(u,2)), depend(Imax,Jmax) :: u2
            real*8, intent(cache,hide), dimension(Imax+1,Jmax+1,shape(u,2)), depend(Imax,Jmax) :: v2
            real*8, intent(cache,hide), dimension(Imax+1,Jmax+1,shape(u,2)), depend(Imax,Jmax) :: w2
            real*8, intent(cache,hide), dimension(Imax+1,Jmax+1,shape(u,2)), depend(Imax,Jmax) :: u3
            real*8, intent(cache,hide), dimension(Imax+1,Jmax+1,shape(u,2)), depend(Imax,Jmax) :: v3
            real*8, intent(cache,hide), dimension(Imax+1,Jmax+1,shape(u,2)), depend(Imax,Jmax) :: w3
            real*8, intent(inout), dimension(Imax+1,Jmax+1,*), depend(Imax,Jmax) :: ox
            real*8, intent(inout), dimension(Imax+1,Jmax+1,*), depend(Imax,Jmax) :: or
            real*8, intent(inout), dimension(Imax+1,Jmax+1,*), depend(Imax,Jmax) :: ot
            real*8, intent(inout), dimension(Imax+1,Jmax+1,*), depend(Imax,Jmax) :: p
            real*8, intent(in) :: cf
            integer, intent(hide), depend(u) :: Imax=(shape(u,0)-1)
            integer, intent(hide), depend(u) :: Jmax=(shape(u,1)-1)
            real*8 dimension(129) :: rt
            real*8 dimension(129) :: rt1
            real*8 dimension(129) :: yt
            real*8 dimension(129) :: yt1
            real*8 :: hr
            integer :: Jm
            real*8 :: hx
            integer :: Im
            integer :: lx
            real*8 :: ht
            integer :: Km
            integer :: lt
            common /dimr/ rt,rt1,yt,yt1,hr,Jm
            common /dimx/ hx,Im,lx
            common /dimt/ ht,Km,lt
        end subroutine step
    end interface 
end python module pipeSym

! This file was auto-generated with f2py (version:2).
! See http://cens.ioc.ee/projects/f2py2e/
