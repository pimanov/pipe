!    -*- f90 -*-
! Note: the context of this file is case sensitive.

python module ductSym_wrap ! in 
    interface  ! in :ductSym_wrap
        subroutine add_nl(u,v,w,ox,or,ot,ut,vt,wt,Imax,Jmax) ! in :ductSym_wrap:add_nl.for
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*) :: u
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: v
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: w
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: ox
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: or
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: ot
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: ut
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: vt
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: wt
            integer, optional,check((shape(u,0)-1)==Imax),depend(u) :: Imax=(shape(u,0)-1)
            integer, optional,check((shape(u,1)-1)==Jmax),depend(u) :: Jmax=(shape(u,1)-1)
            real*8 dimension(130) :: rt1
            real*8 dimension(130) :: yt1
            real*8 :: hr
            integer :: Jm
            real*8 :: hx
            integer :: Im
            integer :: lx
            real*8 :: ht
            integer :: Km
            integer :: lt
            common /dimr/ rt1,yt1,hr,Jm
            common /dimx/ hx,Im,lx
            common /dimt/ ht,Km,lt
        end subroutine add_nl
        subroutine bc_om(u,v,w,ox,or,ot,Imax,Jmax) ! in :ductSym_wrap:bc_om.for
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*) :: u
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: v
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: w
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: ox
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: or
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: ot
            integer, optional,check((shape(u,0)-1)==Imax),depend(u) :: Imax=(shape(u,0)-1)
            integer, optional,check((shape(u,1)-1)==Jmax),depend(u) :: Jmax=(shape(u,1)-1)
            real*8 dimension(130) :: rt1
            real*8 dimension(130) :: yt1
            real*8 :: hr
            integer :: Jm
            real*8 :: hx
            integer :: Im
            integer :: lx
            real*8 :: ht
            integer :: Km
            integer :: lt
            common /dimr/ rt1,yt1,hr,Jm
            common /dimx/ hx,Im,lx
            common /dimt/ ht,Km,lt
        end subroutine bc_om
        subroutine com ! in :ductSym_wrap:com.for
            real*8 :: Xmax
            real*8 :: epsr
            real*8 :: dsym
            real*8 dimension(130) :: rt1
            real*8 dimension(130) :: yt1
            real*8 :: hr
            integer :: Jm
            real*8 :: Re
            real*8 :: ht
            integer :: Km
            integer :: lt
            real*8 :: hx
            integer :: Im
            integer :: lx
            common /dim/ Xmax,epsr,dsym
            common /dimr/ rt1,yt1,hr,Jm
            common /Re/ Re
            common /dimt/ ht,Km,lt
            common /dimx/ hx,Im,lx
        end subroutine com
        subroutine divmax(u,v,w,dd,Imax,Jmax) ! in :ductSym_wrap:divmax.for
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*) :: u
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: v
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: w
            real*8 intent(out) :: dd
            integer, optional,check((shape(u,0)-1)==Imax),depend(u) :: Imax=(shape(u,0)-1)
            integer, optional,check((shape(u,1)-1)==Jmax),depend(u) :: Jmax=(shape(u,1)-1)
            real*8 dimension(130) :: rt1
            real*8 dimension(130) :: yt1
            real*8 :: hr
            integer :: Jm
            real*8 :: hx
            integer :: Im
            integer :: lx
            real*8 :: ht
            integer :: Km
            integer :: lt
            common /dimr/ rt1,yt1,hr,Jm
            common /dimx/ hx,Im,lx
            common /dimt/ ht,Km,lt
        end subroutine divmax
        subroutine init_like_dcp(fncp) ! in :ductSym_wrap:init_like.for
            character*24 :: fncp
            real*8 :: Xmax
            real*8 :: epsr
            real*8 :: dsym
            real*8 :: cf
            real*8 dimension(130) :: rt1
            real*8 dimension(130) :: yt1
            real*8 :: hr
            integer :: Jm
            real*8 :: Re
            real*8 :: ht
            integer :: Km
            integer :: lt
            real*8 :: hx
            integer :: Im
            integer :: lx
            common /dim/ Xmax,epsr,dsym
            common /cf/ cf
            common /dimr/ rt1,yt1,hr,Jm
            common /Re/ Re
            common /dimt/ ht,Km,lt
            common /dimx/ hx,Im,lx
        end subroutine init_like_dcp
        subroutine pres(u,v,w,p,Ub,Imax,Jmax) ! in :ductSym_wrap:pres.for
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*) :: u
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: v
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: w
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: p
            integer, optional,check((shape(u,0)-1)==Imax),depend(u) :: Imax=(shape(u,0)-1)
            integer, optional,check((shape(u,1)-1)==Jmax),depend(u) :: Jmax=(shape(u,1)-1)
            real*8 :: Ub
            real*8 :: Xmax
            real*8 :: epsr
            real*8 :: dsym
            real*8 dimension(130) :: rt1
            real*8 dimension(130) :: yt1
            real*8 :: hr
            integer :: Jm
            real*8 :: ht
            integer :: Km
            integer :: lt
            real*8 :: hx
            integer :: Im
            integer :: lx
            common /dim/ Xmax,epsr,dsym
            common /dimr/ rt1,yt1,hr,Jm
            common /dimt/ ht,Km,lt
            common /dimx/ hx,Im,lx
        end subroutine pres
        subroutine gradp(u,v,w,p,Imax,Jmax) ! in :ductSym_wrap:pres.for
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*) :: u
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: v
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: w
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: p
            integer, optional,check((shape(u,0)-1)==Imax),depend(u) :: Imax=(shape(u,0)-1)
            integer, optional,check((shape(u,1)-1)==Jmax),depend(u) :: Jmax=(shape(u,1)-1)
            real*8 dimension(130) :: rt1
            real*8 dimension(130) :: yt1
            real*8 :: hr
            integer :: Jm
            real*8 :: hx
            integer :: Im
            integer :: lx
            real*8 :: ht
            integer :: Km
            integer :: lt
            common /dimr/ rt1,yt1,hr,Jm
            common /dimx/ hx,Im,lx
            common /dimt/ ht,Km,lt
        end subroutine gradp
        subroutine read_dcp(fncp,u,v,w,t,dt,dp,Imax,Jmax,Kmax) ! in :ductSym_wrap:read.for
            character*24 :: fncp
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,Kmax + 1) :: u
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,Kmax + 1),depend(Imax,Jmax,Kmax) :: v
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,Kmax + 1),depend(Imax,Jmax,Kmax) :: w
            real*8 intent(out) :: t
            real*8 intent(out) :: dt
            real*8 intent(out) :: dp
            integer, optional,check((shape(u,0)-1)==Imax),depend(u) :: Imax=(shape(u,0)-1)
            integer, optional,check((shape(u,1)-1)==Jmax),depend(u) :: Jmax=(shape(u,1)-1)
            integer, optional,check((shape(u,2)-1)==Kmax),depend(u) :: Kmax=(shape(u,2)-1)
            real*8 dimension(130) :: rt1
            real*8 dimension(130) :: yt1
            real*8 :: hr
            integer :: Jm
            real*8 :: Xmax
            real*8 :: epsr
            real*8 :: dsym
            real*8 :: hx
            integer :: Im
            integer :: lx
            real*8 :: ht
            integer :: Km
            integer :: lt
            real*8 :: Re
            common /dimr/ rt1,yt1,hr,Jm
            common /dim/ Xmax,epsr,dsym
            common /dimx/ hx,Im,lx
            common /dimt/ ht,Km,lt
            common /Re/ Re
        end subroutine read_dcp
        subroutine rp(t,u,v,w,ut,vt,wt,ox,or,ot,Imax,Jmax) ! in :ductSym_wrap:rp.for
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*) :: u
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: v
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: w
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: ut
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: vt
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: wt
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: ox
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: or
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: ot
            integer, optional,check((shape(u,0)-1)==Imax),depend(u) :: Imax=(shape(u,0)-1)
            integer, optional,check((shape(u,1)-1)==Jmax),depend(u) :: Jmax=(shape(u,1)-1)
            real*8 :: t
        end subroutine rp
        subroutine step(t,dt,tol,u,v,w,ut,vt,wt,u2,v2,w2,u3,v3,w3,ox,or,ot,p,q,Imax,Jmax) ! in :ductSym_wrap:step.for
            real*8 intent(in,out) :: t
            real*8 intent(in,out) :: dt
            real*8 intent(in,out) :: tol
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*) :: u
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: v
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: w
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: ut
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: vt
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: wt
            real*8 intent(cache,hide),dimension(Imax + 1,Jmax + 1,shape(u,2)),depend(Imax,Jmax) :: u2
            real*8 intent(cache,hide),dimension(Imax + 1,Jmax + 1,shape(u,2)),depend(Imax,Jmax) :: v2
            real*8 intent(cache,hide),dimension(Imax + 1,Jmax + 1,shape(u,2)),depend(Imax,Jmax) :: w2
            real*8 intent(cache,hide),dimension(Imax + 1,Jmax + 1,shape(u,2)),depend(Imax,Jmax) :: u3
            real*8 intent(cache,hide),dimension(Imax + 1,Jmax + 1,shape(u,2)),depend(Imax,Jmax) :: v3
            real*8 intent(cache,hide),dimension(Imax + 1,Jmax + 1,shape(u,2)),depend(Imax,Jmax) :: w3
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: ox
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: or
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: ot
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: p
            real*8 intent(cache,hide),dimension(Imax + 1,Jmax + 1,shape(u,2)),depend(Imax,Jmax) :: q
            integer, optional,check((shape(u,0)-1)==Imax),depend(u) :: Imax=(shape(u,0)-1)
            integer, optional,check((shape(u,1)-1)==Jmax),depend(u) :: Jmax=(shape(u,1)-1)
            real*8 dimension(130) :: rt1
            real*8 dimension(130) :: yt1
            real*8 :: hr
            integer :: Jm
            real*8 :: hx
            integer :: Im
            integer :: lx
            real*8 :: cf
            real*8 :: ht
            integer :: Km
            integer :: lt
            common /dimr/ rt1,yt1,hr,Jm
            common /dimx/ hx,Im,lx
            common /cf/ cf
            common /dimt/ ht,Km,lt
        end subroutine step
        subroutine visc(ox,or,ot,ut,vt,wt,Imax,Jmax) ! in :ductSym_wrap:visc.for
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*) :: ox
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: or
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: ot
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: ut
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: vt
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: wt
            integer, optional,check((shape(ox,0)-1)==Imax),depend(ox) :: Imax=(shape(ox,0)-1)
            integer, optional,check((shape(ox,1)-1)==Jmax),depend(ox) :: Jmax=(shape(ox,1)-1)
            real*8 dimension(130) :: rt1
            real*8 dimension(130) :: yt1
            real*8 :: hr
            integer :: Jm
            real*8 :: Re
            real*8 :: hx
            integer :: Im
            integer :: lx
            real*8 :: ht
            integer :: Km
            integer :: lt
            common /dimr/ rt1,yt1,hr,Jm
            common /Re/ Re
            common /dimx/ hx,Im,lx
            common /dimt/ ht,Km,lt
        end subroutine visc
        subroutine write_dcp(fncp,u,v,w,t,dt,dp,Imax,Jmax) ! in :ductSym_wrap:write.for
            character*24 :: fncp
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*) :: u
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: v
            real*8 intent(inout),dimension(Imax + 1,Jmax + 1,*),depend(Imax,Jmax) :: w
            real*8 intent(in) :: t
            real*8 intent(in) :: dt
            real*8 intent(in) :: dp
            integer, optional,check((shape(u,0)-1)==Imax),depend(u) :: Imax=(shape(u,0)-1)
            integer, optional,check((shape(u,1)-1)==Jmax),depend(u) :: Jmax=(shape(u,1)-1)
            real*8 dimension(130) :: rt1
            real*8 dimension(130) :: yt1
            real*8 :: hr
            integer :: Jm
            real*8 :: Xmax
            real*8 :: epsr
            real*8 :: dsym
            real*8 :: hx
            integer :: Im
            integer :: lx
            real*8 :: ht
            integer :: Km
            integer :: lt
            real*8 :: Re
            common /dimr/ rt1,yt1,hr,Jm
            common /dim/ Xmax,epsr,dsym
            common /dimx/ hx,Im,lx
            common /dimt/ ht,Km,lt
            common /Re/ Re
        end subroutine write_dcp
    end interface 
end python module ductSym_wrap

! This file was auto-generated with f2py (version:2).
! See http://cens.ioc.ee/projects/f2py2e/
